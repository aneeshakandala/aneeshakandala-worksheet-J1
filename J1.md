## 1: What is fault localization? 
Fault localization is ta fancy of way of saying to debug one's code. Essentially, you are tracing back from the line of code producing the incorrect output to where the problem actually is. 

## 2: What are three benefits of Test Driven Development (TDD)? Provide your answer using an unordered list in markdown.
- Your tests are not biased by your code
- Writing tests is helpful for you to think about how you might write your code
- Writing tests can help you to think about the requirements of your system

## 3: Given the example of requirements for generating a password:
  - It must have at least one number.
  - It must have at least one uppercase letter.
  - It must have at least one lowercase letter.
  - It must not contain the website gmail anywhere. (For example if we were generating a password for gmail accounts)
  - It can only be made up of letters, numbers, and the underscore.
  
What are the input domain paritions for this exercise? Provide your answer using an unordered nested lists in markdown.
- It must have at least one number.
    - contains only one number in the middle
      - contains only one number at the start
        - contains only one number at the end
          - missing a number only
  
- It must have at least one uppercase letter.
  - contains only one uppercase letter in the middle
    - contains only one uppercase letter at start
      - contains only one uppercase letter at end
        - missing an uppercase letter only

- It must have at least one lowercase letter.
  - contains only one lowercase letter in middle
    - contains only one lowercase letter at start
      - contains only one lowercase letter at end
        - missing a lowercase letter only

- It must not contain the website gmail anywhere.
  - contains "gmail" in middle
    - contains "gmail" at start
      - contains "gmail" at end
        - does not contain "gmail" (but almost did)
       
- It can only be made up of letters, numbers, and the underscore.
  - one not-allowed character in middle
    - one not-allowed character at start
      - one not-allowed character at end
        - one not-allowed character in middle (that looks close to an allowed character)
          - one not-allowed character at start (that looks close to an allowed character)
            - one not-allowed character at end (that looks close to an allowed character)

## 4: Complete the truth table below to show what inputs we need to achieve active clause coverage for the following conditional:
`if ( ( (a > b) or G ) and (x < y) )`

| a>b | G | x < y | predicate outcome | clause responsible |
|-----|---|-------|------------------| --------------------|
|T |T|T|T| --------------------|
|T |T|F|F| --------------------|
|T |F|T|T| --------------------|
|T |F|F|F| --------------------|
|F |T|T|T| --------------------|
|F |T|F|F| --------------------|
|F |F|T|F| --------------------|
|F |F|F|F| --------------------|
   

## 5: Consider the control flow graph below. What are all the paths (using node numbers) that would achieve full path coverage as a test criteria? Is this a finite set? 

## 6: What benefit does mutation testing offer over other testing methods discussed in class? Use a link in markdown to link to the definition of mutation testing we have in our lecture notes from today.
